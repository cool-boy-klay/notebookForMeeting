# 进程和线程

进程是操作系统分配资源和调度的最小单位，一个进程包括进程代码、数据、进程空间（程序控制块，包括进程的描述信息控制信息）和多个线程

线程是程序执行的最小单位，一个线程包含线程ID、指令指针、寄存器和堆栈

进程和线程的区别：
1. 进程是操作系统分配资源和调度的最小单位，线程是程序执行的最小单位
2. 各个进程之间是隔离的，一个用户进程并不能直接访问到其他用户进程的资源，需要借助进程间通信的方法。而一个进程内的各个线程共享一个进程的代码、数据以及进程级资源（如打开文件和信号）
3. 一个进程拥有多个线程，多个线程是这个进程代码的不同执行路线
4. 线程的上下文切换比进程要快得多，线程的上下文切换只需要保存线程的寄存器状态和堆栈信息即可

# 进程间通信的方式

- 共享内存
- 消息队列
- FIFO
- PIPE



# 死锁

死锁的四个必要条件：
1. 互斥条件：一个资源要么分配给了某个进程，要么就是可用的
2. 占有和等待条件：已经得到了某个资源的进程可以再次请求新的资源（理解：比如线程B已经占有了锁1，现在它还需要再申请锁2才有可能造成死锁）
3. 不可抢占条件：某个资源已经被某个进程A占有的时候，其他进程B不能强行占有抢走该资源，只能等待进程A释放该资源
4. 环路等待条件：死锁发生的时候，一定会有两个以上的进程组成一条环路


避免死锁的银行家算法：
https://www.cnblogs.com/kexinxin/p/11617791.html


避免死锁的方法：

1. 避免一个线程请求多个锁
2. 如果多个线程需求请求多个锁，尽量确保他们请求锁的顺序是一致的。如果线程A先是请求锁A，再请求锁B。而线程B是先请求锁B再请求锁A，那么就会大概率造成死锁。所以我们需要确保两个线程请求同样的锁的顺序是一致的。
3. 使用定时锁，比如使用以下的函数去请求锁,当线程超过一定时间获取不到资源之后就会放弃对锁的请求

``` java
ReentrantLock r = new ReentrantLock();
        r.tryLock(10, TimeUnit.SECONDS);
```

4. 死锁检测算法：使用DFS检测是否有环

死锁恢复的方法：
1. 抢占
2. 杀死进程
3. 回滚


# Linux基本指令

## 改变权限

chmod abc file

其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。

r=4（可读），w=2（可写），x=1（可执行）

r+w+x = 7
r+w = 6
r+x = 5
w+x = 3

所以chmod 777 file 表示User、Grouo、Other的权限都是可读可写可执行

## Top命令

top命令会显示当前系统中占用资源最多的一些进程（默认以CPU占用率排序）如果你想改变排序方式，可以在结果列表中点击O（大写字母O）会显示所有可用于排序的列，这个时候你就可以选择你想排序的列

``` bash
Current Sort Field:  P  for window 1:Def
Select sort field via field letter, type any other key to return
 
  a: PID        = Process Id              v: nDRT       = Dirty Pages count
  d: UID        = User Id                 y: WCHAN      = Sleeping in Function
  e: USER       = User Name               z: Flags      = Task Flags
  ........

```

# 进程和线程的区别

1. 起源不同，历史上是先有进程后有线程的，由于处理机在处理磁盘IO的时间远远大于CPU运算的时间，为了提高处理机的利用率才出现了线程
2. 进程是拥有独立功能的运行起来的一个实例，也是系统分配资源和调度的基本单位。而线程是CPU调度的基本单位。
3. 内存共享方式不同，对于进程而言，每个进程都会被分配一定内存空间，但是一般情况下，一个进程都不能直接访问另外一个进程的资源，比如我们的牛客网浏览器，它是不能直接访问我微信上的内存的。只有使用进程间通信方式比如：管道、信号量、共享内存才能进行进程间通信。而线程与线程间通信很容易，他们可以直接访问一块共享内存。
4. 拥有的资源不同。线程间共享的资源有：1.进程的代码段 2.进程的公有数据 3.进程打开的文件描述符 4.信号的处理器 5.进程的当前目录 6.进程的用户ID和线程组ID。而线程独占的资源有：1.线程ID 2.寄存器组的值 3.线程的堆栈 4，错误返回码 5.线程的信号屏蔽码
5. 一个进程至少要拥有一个线程，同时也可以拥有多个线程
6. 开销不同。1.线程的创建、终止时间比进程短 2.线程的上下文切换开销比进程要小 3.同一个进程的各个线程共享一个进程的内存和文件资源，不需要通过进程间通信

# 进程的调度算法

1. 先来先服务算法：根据就绪队列里面的顺序一一执行
2. 短作业优先算法：估计每个进程的执行时间，先执行预计时间最短的进程
3. 优先级算法：就绪队列的每个进程都有对应的优先级，先执行优先级更高的进程
4. 时间片轮转算法：为每个进程分配一样的时间片，